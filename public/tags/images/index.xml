<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Images on rOpenSci - open tools for open science</title>
    <link>https://ropensci.org/tags/images/</link>
    <description>Recent content in Images on rOpenSci - open tools for open science</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 05 Dec 2017 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://ropensci.org/tags/images/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Magick 1.6: clipping, geometries, fonts, fuzz, and a bit of history</title>
      <link>https://ropensci.org/technotes/2017/12/05/magick-16/</link>
      <pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ropensci.org/technotes/2017/12/05/magick-16/</guid>
      <description>
        
        &lt;img src=&quot;https://i.imgur.com/tTFk7ig.jpg&quot; alt=&quot;cover image&quot;&gt;
        
        

&lt;p&gt;This week &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;magick&lt;/a&gt; 1.6 appeared on CRAN. This release is a big all-round maintenance update with lots of tweaks and improvements across the package.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/NEWS&#34;&gt;NEWS&lt;/a&gt; file gives an overview of changes in this version. In this post we highlight some changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magick)
stopifnot(packageVersion(&#39;magick&#39;) &amp;gt;= 1.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are new to magick, check out the &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;vignette&lt;/a&gt; for a quick introduction.&lt;/p&gt;

&lt;h2 id=&#34;perfect-graphics-rendering&#34;&gt;Perfect Graphics Rendering&lt;/h2&gt;

&lt;p&gt;I have fixed a few small rendering imperfections in the graphics device. The native magick graphics device &lt;code&gt;image_graph()&lt;/code&gt; now renders identical or better quality images as the R-base bitmap devices &lt;code&gt;png&lt;/code&gt;, &lt;code&gt;jpeg&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;One issue was that sometimes magick graphics would show a 1px black border around the image. It turned out this is caused by rounding of clipping coordinates.&lt;/p&gt;

&lt;p&gt;When R calculates clipping area it often ends up at non-whole values. It is then up to the graphics device to decide what to do with the pixel that is partially clipped. Let&amp;rsquo;s show clipping in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;testplot &amp;lt;- function(title = &amp;quot;&amp;quot;){
  plot(1, main = title)
  abline(0, 1, col = &amp;quot;blue&amp;quot;, lwd = 2, lty = &amp;quot;solid&amp;quot;)
  abline(0.1, 1, col = &amp;quot;red&amp;quot;, lwd = 3, lty = &amp;quot;dotted&amp;quot;)
  abline(0.2, 1, col = &amp;quot;green&amp;quot;, lwd = 4, lty = &amp;quot;twodash&amp;quot;)
  abline(0.3, 1, col = &amp;quot;black&amp;quot;, lwd = 5, lty = &amp;quot;dotdash&amp;quot;)
  abline(0.4, 1, col = &amp;quot;purple&amp;quot;, lwd = 6, lty = &amp;quot;dashed&amp;quot;)
  abline(0.5, 1, col = &amp;quot;yellow&amp;quot;, lwd = 7, lty = &amp;quot;longdash&amp;quot;)
  abline(-0.1, 1, col = &amp;quot;blue&amp;quot;, lwd = 10, lend = &amp;quot;round&amp;quot;, lty = &amp;quot;dashed&amp;quot;)
  abline(-0.2, 1, col = &amp;quot;blue&amp;quot;, lwd = 10, lend = &amp;quot;butt&amp;quot;, lty = &amp;quot;dashed&amp;quot;)
  abline(-0.3, 1, col = &amp;quot;blue&amp;quot;, lwd = 10, lend = &amp;quot;square&amp;quot;, lty = &amp;quot;dashed&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we run it with and without clipping:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img2 &amp;lt;- magick::image_graph(clip = FALSE)
testplot(&amp;quot;Without clipping&amp;quot;)
dev.off()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TtpjlLq.png&#34; alt=&#34;noclip.png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img1 &amp;lt;- magick::image_graph(clip = TRUE)
testplot(&amp;quot;With clipping&amp;quot;)
dev.off()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JbWMElL.png&#34; alt=&#34;clip.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see the latter image is now perfectly clipped. The colored lines are truncated exactly at the pixel where the axis starts. This is not always the case in base R ;)&lt;/p&gt;

&lt;h2 id=&#34;font-families&#34;&gt;Font Families&lt;/h2&gt;

&lt;p&gt;In magick there are two ways to render text on an image. You can either open the image or graphic in the magick graphics device and then use base R &lt;code&gt;text()&lt;/code&gt; function to print text. Alternatively there is &lt;code&gt;image_annotate()&lt;/code&gt; which is a simpler version to print some text on an image.&lt;/p&gt;

&lt;p&gt;Wherever text rendering is involved, two major headache arise: encoding and fonts. The latter is tricky because different operating systems have different fonts with different names. In addition a font can be specified as a name, or family name, or alias.&lt;/p&gt;

&lt;p&gt;Below is a simple test that I use to quickly inspect if fonts are working on different systems:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img &amp;lt;- image_graph(width = 800, height = 500, pointsize = 20, res = 96)
graphics::plot.new()
graphics::par(mar = c(0,0,3,0))
graphics::plot.window(xlim = c(0, 20), ylim = c(-.5, 8))
title(expression(Gamma %prop% sum(x[alpha], i==1, n) * sqrt(mu)), expression(hat(x)))

# Standard families as supported by other devices
text(0.95, 7, &amp;quot;abcdefg  - Helvetica&amp;quot;, pos = 4, family = &amp;quot;helvetica&amp;quot;)
text(0.95, 6, &amp;quot;abcdefg  - Sans (Arial)&amp;quot;, pos = 4, family = &amp;quot;sans&amp;quot;)
text(0.95, 5, &amp;quot;abcdefg - Serif (Times)&amp;quot;, pos = 4, family = &amp;quot;serif&amp;quot;)
text(0.95, 4, &amp;quot;abcdefg - Monospace (Courier New)&amp;quot;, pos = 4, family = &amp;quot;mono&amp;quot;)
text(0.95, 3, &amp;quot;abcdefg - Symbol Face&amp;quot;, pos = 4, font = 5)
text(0.95, 2, &amp;quot;abcdefg  - Comic Sans&amp;quot;, pos = 4, family = &amp;quot;Comic Sans&amp;quot;)
text(0.95, 1, &amp;quot;abcdefg - Georgia Serif&amp;quot;, pos = 4, family = &amp;quot;Georgia&amp;quot;)
text(0.95, 0, &amp;quot;abcdefg - Courier&amp;quot;, pos = 4, family = &amp;quot;Courier&amp;quot;)
dev.off()
img &amp;lt;- image_border(img, &#39;red&#39;, geometry = &#39;2x2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tzIktip.png&#34; alt=&#34;families&#34; /&gt;&lt;/p&gt;

&lt;p&gt;R requires that a graphics device supports at least 4 font types: &lt;code&gt;serif&lt;/code&gt;, &lt;code&gt;sans&lt;/code&gt;, &lt;code&gt;mono&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;. The latter is a special 8bit font with some Greek letters and other characters needed for rendering math. This set of fonts corresponds to the original &lt;strong&gt;13 base fonts&lt;/strong&gt; from the &lt;a href=&#34;https://en.wikipedia.org/wiki/PostScript_fonts#Core_Font_Set&#34;&gt;1984 postscript standard&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4x Courier (Regular, Oblique, Bold, Bold Oblique)&lt;/li&gt;
&lt;li&gt;4x Helvetica (Regular, Oblique, Bold, Bold Oblique)&lt;/li&gt;
&lt;li&gt;4x Times (Roman, Italic, Bold, Bold Italic)&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below a photo of the 1985 &lt;a href=&#34;https://en.wikipedia.org/wiki/LaserWriter&#34;&gt;Apple Laser Writer&lt;/a&gt; which was &lt;a href=&#34;https://en.wikipedia.org/wiki/PostScript_fonts#History&#34;&gt;the first laser printer&lt;/a&gt; to use the PostScript language and support all these fonts! Not much later PostScript graphics devices were adopted by R&amp;rsquo;s predecessor &lt;a href=&#34;https://en.wikipedia.org/wiki/S_(programming_language)#.22New_S.22&#34;&gt;&amp;ldquo;The New S&amp;rdquo;&lt;/a&gt; (The New S Language, 1988).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://theappletimeline.com/images/color1000.jpg&#34; alt=&#34;printers&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;geometry-helpers&#34;&gt;Geometry Helpers&lt;/h2&gt;

&lt;p&gt;Another major improvement in this release is the introduction of helper functions for geometry and option strings. Many functions in magick require a special geometry syntax to specify a size, area, or point. For example to resize an image you need to specify a size:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;image_resize(img, &amp;quot;50%&amp;quot;)
image_resize(img, &amp;quot;300x300&amp;quot;)
image_resize(img, &amp;quot;300x300!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or to crop you need to specify an area which consists of a size and offset:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;image_crop(img, &amp;quot;300x300+100+100&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We added a few handy &lt;code&gt;?geometry&lt;/code&gt; helper functions to generate proper geometry syntax&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2jivLxi.png&#34; alt=&#34;geometries&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;magick-options&#34;&gt;Magick Options&lt;/h2&gt;

&lt;p&gt;A lot of the power in ImageMagick is contained in the hundreds of built-in filters, colorspaces, compose operators, disposal types, convolution kernels, noise types and what not. These are specified simply as a string in the function.&lt;/p&gt;

&lt;p&gt;For example in our previous &lt;a href=&#34;https://ropensci.org/technotes/2017/11/02/image-convolve/&#34;&gt;post about Image Convolution&lt;/a&gt; we discussed a few kernel types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Gaussian Kernel
img %&amp;gt;% image_convolve(&#39;Gaussian:0x5&#39;, scaling = &#39;60,40%&#39;)

# Sobel Kernel
img %&amp;gt;% image_convolve(&#39;Sobel&#39;)

# Difference of Gaussians
img %&amp;gt;% image_convolve(&#39;DoG:0,0,2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supported values for each option are described in the online ImageMagick documentation. We now have added functions in the magick package that list all values for each option. This should make it a easier to see what is supported and harness the full power of built-in ImageMagick algorithms.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cid6JqU.png&#34; alt=&#34;options&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So we can now easily list e.g. supported kernel types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&amp;gt; kernel_types()
 [1] &amp;quot;Undefined&amp;quot;     &amp;quot;Unity&amp;quot;         &amp;quot;Gaussian&amp;quot;      &amp;quot;DoG&amp;quot;          
 [5] &amp;quot;LoG&amp;quot;           &amp;quot;Blur&amp;quot;          &amp;quot;Comet&amp;quot;         &amp;quot;Binomial&amp;quot;     
 [9] &amp;quot;Laplacian&amp;quot;     &amp;quot;Sobel&amp;quot;         &amp;quot;FreiChen&amp;quot;      &amp;quot;Roberts&amp;quot;      
[13] &amp;quot;Prewitt&amp;quot;       &amp;quot;Compass&amp;quot;       &amp;quot;Kirsch&amp;quot;        &amp;quot;Diamond&amp;quot;      
[17] &amp;quot;Square&amp;quot;        &amp;quot;Rectangle&amp;quot;     &amp;quot;Disk&amp;quot;          &amp;quot;Octagon&amp;quot;      
[21] &amp;quot;Plus&amp;quot;          &amp;quot;Cross&amp;quot;         &amp;quot;Ring&amp;quot;          &amp;quot;Peaks&amp;quot;        
[25] &amp;quot;Edges&amp;quot;         &amp;quot;Corners&amp;quot;       &amp;quot;Diagonals&amp;quot;     &amp;quot;ThinDiagonals&amp;quot;
[29] &amp;quot;LineEnds&amp;quot;      &amp;quot;LineJunctions&amp;quot; &amp;quot;Ridges&amp;quot;        &amp;quot;ConvexHull&amp;quot;   
[33] &amp;quot;ThinSe&amp;quot;        &amp;quot;Skeleton&amp;quot;      &amp;quot;Chebyshev&amp;quot;     &amp;quot;Manhattan&amp;quot;    
[37] &amp;quot;Octagonal&amp;quot;     &amp;quot;Euclidean&amp;quot;     &amp;quot;User Defined&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot of kernels.&lt;/p&gt;

&lt;h2 id=&#34;fuzz-scaling&#34;&gt;Fuzz Scaling&lt;/h2&gt;

&lt;p&gt;Finally one more (breaking) change: several functions in magick use a &lt;code&gt;fuzz&lt;/code&gt; parameter to specify the max distance between two colors to be considered similar.&lt;/p&gt;

&lt;p&gt;For example the flood fill algorithm (the paint-bucket button in ms-paint) changes the color of a given starting pixel, and then recursively all adjacent pixels that have the same color. However sometimes neighboring pixels are not precisely the same color, but nearly the same. The &lt;code&gt;fuzz&lt;/code&gt; parameter allows the fill to continue when pixels are not the same but similar color.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Paint the shirt orange
frink &amp;lt;- image_read(&amp;quot;https://jeroen.github.io/images/frink.png&amp;quot;) %&amp;gt;%
  image_fill(&amp;quot;orange&amp;quot;, point = &amp;quot;+100+200&amp;quot;, fuzz = 25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VwlqYWy.png&#34; alt=&#34;frink&#34; /&gt;&lt;/p&gt;

&lt;p&gt;What has changed in this version is that &lt;code&gt;fuzz&lt;/code&gt; parameter been rescaled to a percentage. Hence you should always provide a value between 0 and 100. Previously it was the absolute distance between colors, but this depends on the type and color depth of the image at hand, which was very confusing.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Using Magick with RMarkdown and Shiny</title>
      <link>https://ropensci.org/technotes/2017/11/07/magick-knitr/</link>
      <pubDate>Tue, 07 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ropensci.org/technotes/2017/11/07/magick-knitr/</guid>
      <description>
        
        &lt;img src=&quot;https://i.imgur.com/tTFk7ig.jpg&quot; alt=&quot;cover image&quot;&gt;
        
        

&lt;p&gt;This week &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;magick&lt;/a&gt; 1.5 appeared on CRAN. The latest update adds support for using images in knitr documents and shiny apps. In this post we show how this nicely ties together a reproducible image workflow in R, from source image or plot directly into your report or application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magick)
stopifnot(packageVersion(&#39;magick&#39;) &amp;gt;= 1.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also the magick &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;intro vignette&lt;/a&gt; has been updated in this version to cover the latest features available in the package.&lt;/p&gt;

&lt;h2 id=&#34;magick-in-knitr-rmarkdown-documents&#34;&gt;Magick in Knitr / RMarkdown Documents&lt;/h2&gt;

&lt;p&gt;Magick 1.5 is now fully compatible with knitr. To embed magick images in your rmarkdown report, simply use standard code chunk syntax in your &lt;code&gt;Rmd&lt;/code&gt; file. No special options or packages are required; the image automatically appears in your documents when printed!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Example from our post last week
image_read(&#39;logo:&#39;) %&amp;gt;%
  image_convolve(&#39;DoG:0,0,2&#39;) %&amp;gt;%
  image_negate() %&amp;gt;%
  image_resize(&amp;quot;400x400&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PhwCJ4k.gif&#34; alt=&#34;fig1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can also combine this with the magick graphics device to post process or animate your plots and figures directly in knitr. Again no special packages or system dependencies are required.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Produce graphic
fig &amp;lt;- image_graph(width = 800, height = 600, res = 96)
ggplot2::qplot(factor(cyl), data = mtcars, fill = factor(gear))
invisible(dev.off())

print(fig)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zFLcHws.png&#34; alt=&#34;fig2&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;
# Some post-processing
frink &amp;lt;- image_read(&amp;quot;https://jeroen.github.io/images/frink.png&amp;quot;)

fig %&amp;gt;%
  image_rotate(10) %&amp;gt;%
  image_implode(.6) %&amp;gt;%
  image_composite(frink, offset = &amp;quot;+140+70&amp;quot;) %&amp;gt;%
  image_annotate(&amp;quot;Very usefull stuff&amp;quot;, size = 40, location = &amp;quot;+300+100&amp;quot;, color = &amp;quot;navy&amp;quot;, boxcolor = &amp;quot;pink&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0E5cqaz.png&#34; alt=&#34;fig3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Same works for animation with &lt;code&gt;image_animate()&lt;/code&gt;; the figure shows automatically up in the report as a gif image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;image_read(&amp;quot;https://jeroen.github.io/images/banana.gif&amp;quot;) %&amp;gt;%
  image_apply( function(banana){
    image_composite(fig, banana, offset = &amp;quot;+200+200&amp;quot;)
  }) %&amp;gt;%
  image_resize(&amp;quot;50%&amp;quot;) %&amp;gt;%
  image_animate()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mi67gjt.gif&#34; alt=&#34;fig4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The magick vignette &lt;a href=&#34;https://raw.githubusercontent.com/ropensci/magick/master/vignettes/intro.Rmd&#34;&gt;source code&lt;/a&gt; is itself written in Rmarkdown, so it&amp;rsquo;s great example to see this in action. Try rendering it in RStudio to see how easy it is!&lt;/p&gt;

&lt;h2 id=&#34;magick-in-shiny-apps&#34;&gt;Magick in Shiny Apps&lt;/h2&gt;

&lt;p&gt;While we&amp;rsquo;re at it, several people had asked how to use magick images in shiny apps. The easiest way is to write the image to a &lt;code&gt;tempfile()&lt;/code&gt; within the &lt;code&gt;renderImage()&lt;/code&gt; callback function. For example the server part could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;output$img &amp;lt;- renderImage({
    tmpfile &amp;lt;- image %&amp;gt;%
      image_resize(input$size) %&amp;gt;%
      image_implode(input$implode) %&amp;gt;%
      image_blur(input$blur, input$blur) %&amp;gt;%
      image_rotate(input$rotation) %&amp;gt;%
      image_write(tempfile(fileext=&#39;jpg&#39;), format = &#39;jpg&#39;)

  # Return a list
  list(src = tmpfile, contentType = &amp;quot;image/jpeg&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is a simple shiny app that demonstrates this. Have a look at the &lt;a href=&#34;https://github.com/jeroen/shinymagick/blob/master/app.R&#34;&gt;source code&lt;/a&gt; or just run it in R:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(shiny)
library(magick)
runGitHub(&amp;quot;jeroen/shinymagick&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://jeroen.shinyapps.io/shinymagick&#34;&gt;&lt;img src=&#34;https://i.imgur.com/tTFk7ig.jpg&#34; alt=&#34;tigrou&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perhaps there&amp;rsquo;s an even better way to make this work by wrapping magick images into an htmlwidget but I have not figured this out yet.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Image Convolution in R using Magick</title>
      <link>https://ropensci.org/technotes/2017/11/02/image-convolve/</link>
      <pubDate>Thu, 02 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ropensci.org/technotes/2017/11/02/image-convolve/</guid>
      <description>
        
        

&lt;p&gt;Release 1.4 of the &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;magick package&lt;/a&gt; introduces
a new feature called &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution&#34;&gt;image convolution&lt;/a&gt; that
was requested by Thomas L. Pedersen. In this post we explain what this is all about.&lt;/p&gt;

&lt;h2 id=&#34;kernel-matrix&#34;&gt;Kernel Matrix&lt;/h2&gt;

&lt;p&gt;The new &lt;code&gt;image_convolve()&lt;/code&gt; function applies a &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_(image_processing)&#34;&gt;kernel&lt;/a&gt; over the image. Kernel convolution means that each pixel value is recalculated using the &lt;em&gt;weighted neighborhood sum&lt;/em&gt; defined in the kernel matrix. For example lets look at this simple kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(magick)

kern &amp;lt;- matrix(0, ncol = 3, nrow = 3)
kern[1, 2] &amp;lt;- 0.25
kern[2, c(1, 3)] &amp;lt;- 0.25
kern[3, 2] &amp;lt;- 0.25
kern
##      [,1] [,2] [,3]
## [1,] 0.00 0.25 0.00
## [2,] 0.25 0.00 0.25
## [3,] 0.00 0.25 0.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This kernel changes each pixel to the mean of its horizontal and vertical neighboring pixels, which results in a slight blurring effect in the right-hand image below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img &amp;lt;- image_read(&#39;logo:&#39;)
img_blurred &amp;lt;- image_convolve(img, kern)
image_append(c(img, img_blurred))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Y6xByUL.gif&#34; alt=&#34;image_appended&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;standard-kernels&#34;&gt;Standard Kernels&lt;/h2&gt;

&lt;p&gt;Many operations in &lt;code&gt;magick&lt;/code&gt;  such as blurring, sharpening, and edge detection are
actually special cases of image convolution. The benefit of explicitly using
&lt;code&gt;image_convolve()&lt;/code&gt; is more control. For example, we can blur an image and then blend
it together with the original image in one step by mixing a blurring kernel with the
unit kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img %&amp;gt;% image_convolve(&#39;Gaussian:0x5&#39;, scaling = &#39;60,40%&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6Vf6c2hl.gif&#34; alt=&#34;mixed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The above requires a bit of explanation. ImageMagick defines several common
&lt;a href=&#34;http://www.imagemagick.org/Usage/convolve/&#34;&gt;standard kernels&lt;/a&gt; such as the
gaussian kernel. Most of the standard kernels take one or more parameters,
e.g. the example above used a gaussian kernel with 0 &lt;em&gt;radius&lt;/em&gt; and 5 &lt;em&gt;sigma&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In addition, &lt;code&gt;scaling&lt;/code&gt; argument defines the magnitude of the kernel, and possibly
how much of the original picture should be mixed in. Here we mix 60% of the
blurring with 40% of the original picture in order to get a diffused lightning effect.&lt;/p&gt;

&lt;h2 id=&#34;edge-detection&#34;&gt;Edge Detection&lt;/h2&gt;

&lt;p&gt;Another area where kernels are of use is in edge detection. A simple example of
a direction-aware edge detection kernel is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Sobel_operator&#34;&gt;&lt;em&gt;Sobel&lt;/em&gt;&lt;/a&gt; kernel.
As can be seen below, vertical edges are detected while horizontals are not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img %&amp;gt;% image_convolve(&#39;Sobel&#39;) %&amp;gt;% image_negate()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/i8ndfCu.gif&#34; alt=&#34;edges&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Something less apparent is that the result of the edge detection is truncated.
Edge detection kernels can result in negative color values which get truncated to zero.
To combat this it is possible to add a &lt;code&gt;bias&lt;/code&gt; to the result. Often you&amp;rsquo;ll end up with
scaling the kernel to 50% and adding 50% bias to move the midpoint of the result to 50%
grey:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img %&amp;gt;% image_convolve(&#39;Sobel&#39;, scaling = &#39;50%&#39;, bias = &#39;50%&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/llUawrg.gif&#34; alt=&#34;50pct&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;sharpening&#34;&gt;Sharpening&lt;/h2&gt;

&lt;p&gt;ImageMagick has many more edge detection kernels, some of which are insensitive to
the direction of the edge. To emulate a classic high-pass filter from photoshop use
&lt;a href=&#34;https://en.wikipedia.org/wiki/Difference_of_Gaussians&#34;&gt;difference of gaussians&lt;/a&gt; kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img %&amp;gt;% image_convolve(&#39;DoG:0,0,2&#39;) %&amp;gt;% image_negate()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/o5kODpc.gif&#34; alt=&#34;dog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As with the blurring, the original image can be blended in with the transformed one, effectively sharpening the image along edges.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;img %&amp;gt;% image_convolve(&#39;DoG:0,0,2&#39;, scaling = &#39;100, 100%&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MtcMSn7.gif&#34; alt=&#34;combination&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.imagemagick.org/Usage/convolve/&#34;&gt;ImageMagick documentation&lt;/a&gt; has more examples of convolve with various avaiable kernels.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Magick 1.0: üé© ‚ú®üêá Advanced Graphics and Image Processing in R </title>
      <link>https://ropensci.org/blog/2017/08/15/magick-10/</link>
      <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ropensci.org/blog/2017/08/15/magick-10/</guid>
      <description>
        
        

&lt;p&gt;Last week, version 1.0 of the &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/index.html&#34;&gt;magick&lt;/a&gt; package appeared on CRAN: an ambitious effort to modernize and simplify high quality image processing in R. This R package builds upon the &lt;a href=&#34;https://www.imagemagick.org/Magick++/STL.html&#34;&gt;Magick++ STL&lt;/a&gt; which exposes a powerful C++ API to the famous ImageMagick library.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jeroen.github.io/images/magick.png&#34; alt=&#34;RStudio Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The best place to start learning about magick is the &lt;a href=&#34;https://cran.r-project.org/web/packages/magick/vignettes/intro.html&#34;&gt;vignette&lt;/a&gt; which gives a brief overview of the overwhelming amount of functionality in this package.&lt;/p&gt;

&lt;h3 id=&#34;towards-release-1-0&#34;&gt;Towards Release 1.0&lt;/h3&gt;

&lt;p&gt;Last year around this time rOpenSci &lt;a href=&#34;https://ropensci.org/blog/blog/2016/08/23/z-magick-release&#34;&gt;announced&lt;/a&gt; the first release of the magick package: a new powerful toolkit for image reading, writing, converting, editing, transformation, annotation, and animation in R. Since the initial release there have been several updates with additional functionality, and many useRs have started to discover the power of this package to take visualization in R to the next level.&lt;/p&gt;

&lt;p&gt;For example &lt;a href=&#34;https://twitter.com/hrbrmstr/status/758304420224466944&#34;&gt;Bob Rudis&lt;/a&gt; uses magick to visualize California drought data from the U.S. Drought Monitor (click on the image to go find out more):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://rud.is/b/2016/07/27/u-s-drought-animations-with-the-witchs-brew-purrr-broom-magick/&#34;&gt;&lt;img src=&#34;https://jeroen.github.io/images/drought.gif&#34; alt=&#34;drought&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;R-ladies &lt;a href=&#34;http://www.lucymcgowan.com/&#34;&gt;Lucy D&amp;rsquo;Agostino McGowan&lt;/a&gt; and &lt;a href=&#34;http://www.masalmon.eu/&#34;&gt;Ma√´lle Salmon&lt;/a&gt; demonstrate how to make a beautiful collage:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://livefreeordichotomize.com/2017/07/18/the-making-of-we-r-ladies/&#34;&gt;&lt;img src=&#34;http://livefreeordichotomize.com/images/we-r-ladies.jpeg&#34; alt=&#34;collage&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And &lt;a href=&#34;https://twitter.com/danielphadley/status/884845188979359744&#34;&gt;Daniel P. Hadley&lt;/a&gt; lets Vincent Vega explains Cars:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://danielphadley.com/ggplot-Logo/&#34;&gt;&lt;img src=&#34;http://danielphadley.com/images/Cars_Travolta.gif&#34; alt=&#34;travolta&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now, 1 year later, the 1.0 release marks an important milestone: the addition of a new native graphics device (which serves as a hybrid between a magick image object and an R plot) bridges the gap between graphics and image processing in R.&lt;/p&gt;

&lt;p&gt;This blog post explains how the magick device allows you to seamlessly combine graphing with image processing in R. You can either use it to post-process your R graphics, or draw on imported images using the native R plotting machinery. We hope that this unified interface will make it easier to produce beautiful, reproducible images with R.&lt;/p&gt;

&lt;h3 id=&#34;native-magick-graphics&#34;&gt;Native Magick Graphics&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;image_graph()&lt;/code&gt; function opens a new graphics device similar to e.g. &lt;code&gt;png()&lt;/code&gt; or &lt;code&gt;x11()&lt;/code&gt;. It returns an image object to which the plot(s) will be written. Each page in the plotting device will become a frame (layer) in the image object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Produce image using graphics device
fig &amp;lt;- image_graph(res = 96)
ggplot2::qplot(mpg, wt, data = mtcars, colour = cyl)
dev.off()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fig&lt;/code&gt; object now contains the image that we can easily post-process. For example we can overlay another image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;logo &amp;lt;- image_read(&amp;quot;https://www.r-project.org/logo/Rlogo.png&amp;quot;)
out &amp;lt;- image_composite(fig, image_scale(logo, &amp;quot;x150&amp;quot;), offset = &amp;quot;+80+380&amp;quot;)

# Show preview
image_browse(out)

# Write to file
image_write(out, &amp;quot;myplot.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ropensci.org/assets/blog-images/2017-08-15-magick-10/out.png&#34; alt=&#34;out&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;drawing-device&#34;&gt;Drawing Device&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;image_draw()&lt;/code&gt; function opens a graphics device to draw on top of an existing image using pixel coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Open a file
library(magick)
frink &amp;lt;- image_read(&amp;quot;https://jeroen.github.io/images/frink.png&amp;quot;)
drawing &amp;lt;- image_draw(frink)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://jeroen.github.io/images/frink.png&#34; alt=&#34;frink&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can now use R&amp;rsquo;s native low-level graphics functions for drawing on top of the image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rect(20, 20, 200, 100, border = &amp;quot;red&amp;quot;, lty = &amp;quot;dashed&amp;quot;, lwd = 5)
abline(h = 300, col = &#39;blue&#39;, lwd = &#39;10&#39;, lty = &amp;quot;dotted&amp;quot;)
text(10, 250, &amp;quot;Hoiven-Glaven&amp;quot;, family = &amp;quot;courier&amp;quot;, cex = 4, srt = 90)
palette(rainbow(11, end = 0.9))
symbols(rep(200, 11), seq(0, 400, 40), circles = runif(11, 5, 35),
  bg = 1:11, inches = FALSE, add = TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At any point you can inspect the current result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image_browse(drawing)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ropensci.org/assets/blog-images/2017-08-15-magick-10/drawing.png&#34; alt=&#34;drawing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once you are done you can close the device and save the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dev.off()
image_write(drawing, &#39;drawing.png&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default &lt;code&gt;image_draw()&lt;/code&gt; sets all margins to 0 and uses graphics coordinates to match image size in pixels (width x height) where (0,0) is the top left corner. Note that this means the y axis increases from top to bottom which is the opposite of typical graphics coordinates. You can override all this by passing custom &lt;code&gt;xlim&lt;/code&gt;, &lt;code&gt;ylim&lt;/code&gt; or &lt;code&gt;mar&lt;/code&gt; values to &lt;code&gt;image_draw()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;animated-graphics&#34;&gt;Animated Graphics&lt;/h3&gt;

&lt;p&gt;The graphics device supports multiple frames which makes it easy to create animated graphics. The example below shows how you would implement the example from the very cool &lt;a href=&#34;https://github.com/dgrtwo/gganimate&#34;&gt;gganimate&lt;/a&gt; package using the magick.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(gapminder)
library(ggplot2)
library(magick)
img &amp;lt;- image_graph(res = 96)
datalist &amp;lt;- split(gapminder, gapminder$year)
out &amp;lt;- lapply(datalist, function(data){
  p &amp;lt;- ggplot(data, aes(gdpPercap, lifeExp, size = pop, color = continent)) +
    scale_size(&amp;quot;population&amp;quot;, limits = range(gapminder$pop)) +
    scale_x_log10(limits = range(gapminder$gdpPercap)) +
    geom_point() + ylim(20, 90) +  ggtitle(data$year) + theme_classic()
  print(p)
})
dev.off()
animation &amp;lt;- image_animate(img, fps = 2)
image_write(animation, &amp;quot;animation.gif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ropensci.org/assets/blog-images/2017-08-15-magick-10/animation.gif&#34; alt=&#34;animation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We hope that the magick package can provide a more robust back-end for packages like gganimate to produce interactive graphics in R without requiring the user to manually install external image editing software.&lt;/p&gt;

&lt;h3 id=&#34;porting-imagemagick-commands-to-r&#34;&gt;Porting ImageMagick Commands to R&lt;/h3&gt;

&lt;p&gt;The magick 1.0 release now has the core image processing functionality that you expect from an image processing package. But there is still a lot of room for improvement to make magick &lt;em&gt;the&lt;/em&gt; image processing package in R.&lt;/p&gt;

&lt;p&gt;A lot of R users and packages currently shell out to ImageMagick command line tools for performing image manipulations. The goal is to support all these operations in the magick package, so that the images can be produced (and reproduced!) on any platform without requiring the user to install additional software.&lt;/p&gt;

&lt;p&gt;Note that ImageMagick library is over 26 years old and has accumulated an enormous number of features in those years. Porting all of this to R is quite a bit of work, for which feedback from users is important. If there is an imagemagick operation that you like to do in R but you can&amp;rsquo;t figure out how, please &lt;a href=&#34;https://github.com/ropensci/magick/issues&#34;&gt;open an issue&lt;/a&gt; on GitHub. If the functionality is currently not supported yet, we will try to add it to the next version.&lt;/p&gt;

&lt;h3 id=&#34;image-analysis&#34;&gt;Image Analysis&lt;/h3&gt;

&lt;p&gt;Currently magick is focused on generating and editing images. There is yet another entirely different set of features which we like to support related to analyzing images. Image analysis can involve anything from calculating color distributions to more sophisticated feature extraction and vision tools. I am not very familiar with this field, so again we could use suggestions from users and experts.&lt;/p&gt;

&lt;p&gt;One feature that is already available is the &lt;code&gt;image_ocr()&lt;/code&gt; function which extracts text from the image using the rOpenSci &lt;a href=&#34;https://ropensci.org/blog/blog/2016/11/16/tesseract&#34;&gt;tesseract&lt;/a&gt; package. Another cool example of using image analysis is the &lt;a href=&#34;https://github.com/ThinkRstat/collage&#34;&gt;collage&lt;/a&gt; package which calculates &lt;a href=&#34;https://github.com/ThinkRstat/collage#histograms&#34;&gt;color histograms&lt;/a&gt; to select appropriate tile images for creating a collage.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ThinkRstat/collage#histograms&#34;&gt;&lt;img src=&#34;https://github.com/ThinkRstat/collage/raw/master/README-histograms-2.png&#34; alt=&#34;histogram&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As part of supporting supporting analysis tools we plan to extract the bitmap (raster) classes into a separate package. This will enable package authors to write R extensions to analyze and manipulate on the raw image data, without necessarily depending on magick. Yet the user can always rely on magick as a powerful toolkit to import/export images and graphics into such low level bitmaps.&lt;/p&gt;

&lt;div class=&#34;col-sm-11 col-sm-offset-1&#34;&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;
&lt;a href=&#34;https://twitter.com/grbails/status/885543687559811073&#34;&gt;&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
